<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XFunit: m_xfunit_unit_list_ftl Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">XFunit<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">Unit Test framework for Fortran</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle"><div class="title">m_xfunit_unit_list_ftl Module Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__xfunit__unit__list__ftl_1_1binary__predicate.html">binary_predicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__xfunit__unit__list__ftl_1_1comparison.html">comparison</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__xfunit__unit__list__ftl_1_1distance.html">distance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interfaces for procedures not bound to type.  <a href="interfacem__xfunit__unit__list__ftl_1_1distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__xfunit__unit__list__ftl_1_1predicate.html">predicate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__xfunit__unit__list__ftl_1_1swap.html">swap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structm__xfunit__unit__list__ftl_1_1t__list__node.html">t_list_node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">List node type.  <a href="structm__xfunit__unit__list__ftl_1_1t__list__node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double linked list container type.  <a href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">type &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double linked list iterator type.  <a href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacem__xfunit__unit__list__ftl_1_1xfunit__unit__list__ftl.html">xfunit_unit_list_ftl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor interface.  <a href="interfacem__xfunit__unit__list__ftl_1_1xfunit__unit__list__ftl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a604849261576666eb8721e373dbd29d4"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a604849261576666eb8721e373dbd29d4">list_default</a> ()</td></tr>
<tr class="memdesc:a604849261576666eb8721e373dbd29d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">(1) empty container constructor (default constructor) Constructs an empty container, with no elements.  <a href="namespacem__xfunit__unit__list__ftl.html#a604849261576666eb8721e373dbd29d4">More...</a><br /></td></tr>
<tr class="separator:a604849261576666eb8721e373dbd29d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8b77361a1e14072e8eddf42b193c5e"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a6e8b77361a1e14072e8eddf42b193c5e">list_fill</a> (n, val)</td></tr>
<tr class="memdesc:a6e8b77361a1e14072e8eddf42b193c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(2) fill constructor Constructs a container with n elements. Each element is a copy of val.  <a href="namespacem__xfunit__unit__list__ftl.html#a6e8b77361a1e14072e8eddf42b193c5e">More...</a><br /></td></tr>
<tr class="separator:a6e8b77361a1e14072e8eddf42b193c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf06038330239320cdb0802f6e328811"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#abf06038330239320cdb0802f6e328811">list_range</a> (first, last)</td></tr>
<tr class="memdesc:abf06038330239320cdb0802f6e328811"><td class="mdescLeft">&#160;</td><td class="mdescRight">(3) range constructor Constructs a container with as many elements as the range (first,last), with each element constructed from its corresponding element in that range, in the same order. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type  <a href="namespacem__xfunit__unit__list__ftl.html#abf06038330239320cdb0802f6e328811">More...</a><br /></td></tr>
<tr class="separator:abf06038330239320cdb0802f6e328811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0322bf8cd3a6e20cfa1f4f8b8a52be2"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#ab0322bf8cd3a6e20cfa1f4f8b8a52be2">list_copy</a> (other)</td></tr>
<tr class="memdesc:ab0322bf8cd3a6e20cfa1f4f8b8a52be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">(4) copy constructor Constructs a container with a copy of each of the elements in other, in the same order.  <a href="namespacem__xfunit__unit__list__ftl.html#ab0322bf8cd3a6e20cfa1f4f8b8a52be2">More...</a><br /></td></tr>
<tr class="separator:ab0322bf8cd3a6e20cfa1f4f8b8a52be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006c513fce1f34d68ed5fbf10f220329"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a006c513fce1f34d68ed5fbf10f220329">list_copy_from_array</a> (val)</td></tr>
<tr class="memdesc:a006c513fce1f34d68ed5fbf10f220329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor from array.  <a href="namespacem__xfunit__unit__list__ftl.html#a006c513fce1f34d68ed5fbf10f220329">More...</a><br /></td></tr>
<tr class="separator:a006c513fce1f34d68ed5fbf10f220329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a0bcd70089f0fb22e04eeeba989a01"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#af1a0bcd70089f0fb22e04eeeba989a01">list_assign_from_list</a> (this, other)</td></tr>
<tr class="memdesc:af1a0bcd70089f0fb22e04eeeba989a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign content Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.  <a href="namespacem__xfunit__unit__list__ftl.html#af1a0bcd70089f0fb22e04eeeba989a01">More...</a><br /></td></tr>
<tr class="separator:af1a0bcd70089f0fb22e04eeeba989a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff79a9de2cc481c6ecaa31b9f88a548"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a7ff79a9de2cc481c6ecaa31b9f88a548">list_</a> (this)</td></tr>
<tr class="memdesc:a7ff79a9de2cc481c6ecaa31b9f88a548"><td class="mdescLeft">&#160;</td><td class="mdescRight">List destructor Destroys the container object.  <a href="namespacem__xfunit__unit__list__ftl.html#a7ff79a9de2cc481c6ecaa31b9f88a548">More...</a><br /></td></tr>
<tr class="separator:a7ff79a9de2cc481c6ecaa31b9f88a548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de5e17830aa3f0d9aa2d25497e3300d"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a0de5e17830aa3f0d9aa2d25497e3300d">list_begin</a> (this)</td></tr>
<tr class="memdesc:a0de5e17830aa3f0d9aa2d25497e3300d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to beginning Returns an iterator pointing to the first element in the list container. If the container is empty, the returned iterator value shall not be dereferenced.  <a href="namespacem__xfunit__unit__list__ftl.html#a0de5e17830aa3f0d9aa2d25497e3300d">More...</a><br /></td></tr>
<tr class="separator:a0de5e17830aa3f0d9aa2d25497e3300d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae697f5792f9cfd64326858fc0f3027"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#acae697f5792f9cfd64326858fc0f3027">list_end</a> (this)</td></tr>
<tr class="memdesc:acae697f5792f9cfd64326858fc0f3027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to end Returns an iterator referring to the last element in the list container. If the container is empty, the returned iterator value shall not be dereferenced.  <a href="namespacem__xfunit__unit__list__ftl.html#acae697f5792f9cfd64326858fc0f3027">More...</a><br /></td></tr>
<tr class="separator:acae697f5792f9cfd64326858fc0f3027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e01314b60f763d04b3ea4cd5e2bdf"><td class="memItemLeft" align="right" valign="top">pure <a class="el" href="interfacem__util__convert_1_1logical.html">logical</a> function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a417e01314b60f763d04b3ea4cd5e2bdf">list_empty</a> (this)</td></tr>
<tr class="memdesc:a417e01314b60f763d04b3ea4cd5e2bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether container is empty Returns whether the list container is empty (i.e. whether its size is 0). This function does not modify the container in any way.  <a href="namespacem__xfunit__unit__list__ftl.html#a417e01314b60f763d04b3ea4cd5e2bdf">More...</a><br /></td></tr>
<tr class="separator:a417e01314b60f763d04b3ea4cd5e2bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf4b3ee8abea3c4cbedaea415fb09ec"><td class="memItemLeft" align="right" valign="top">pure <a class="el" href="interfacem__util__convert_1_1integer.html">integer</a> function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#aecf4b3ee8abea3c4cbedaea415fb09ec">list_size</a> (this)</td></tr>
<tr class="memdesc:aecf4b3ee8abea3c4cbedaea415fb09ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return size Returns the number of elements in the list container.  <a href="namespacem__xfunit__unit__list__ftl.html#aecf4b3ee8abea3c4cbedaea415fb09ec">More...</a><br /></td></tr>
<tr class="separator:aecf4b3ee8abea3c4cbedaea415fb09ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3aad07af32e9c866f6133532b6d117"><td class="memItemLeft" align="right" valign="top">pure <a class="el" href="interfacem__util__convert_1_1integer.html">integer</a> function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a4d3aad07af32e9c866f6133532b6d117">list_max_size</a> ()</td></tr>
<tr class="memdesc:a4d3aad07af32e9c866f6133532b6d117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return maximum size Returns the maximum number of elements that the list container can hold. This is the maximum potential size the container can reach due to known system or library implementation limitations, but the container is by no means guaranteed to be able to reach that size: it can still fail to allocate storage at any point before that size is reached.  <a href="namespacem__xfunit__unit__list__ftl.html#a4d3aad07af32e9c866f6133532b6d117">More...</a><br /></td></tr>
<tr class="separator:a4d3aad07af32e9c866f6133532b6d117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0bb9e23aa8c5f2895e0095158303b3"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a6b0bb9e23aa8c5f2895e0095158303b3">list_front</a> (this)</td></tr>
<tr class="memdesc:a6b0bb9e23aa8c5f2895e0095158303b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access first element Returns a reference to the first element in the list container. Calling this function on an empty container causes undefined behaviour.  <a href="namespacem__xfunit__unit__list__ftl.html#a6b0bb9e23aa8c5f2895e0095158303b3">More...</a><br /></td></tr>
<tr class="separator:a6b0bb9e23aa8c5f2895e0095158303b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02614cef81338b62464b14444cd888fe"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a02614cef81338b62464b14444cd888fe">list_back</a> (this)</td></tr>
<tr class="memdesc:a02614cef81338b62464b14444cd888fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access last element Returns a reference to the last element in the list container. Calling this function on an empty container causes undefined behaviour.  <a href="namespacem__xfunit__unit__list__ftl.html#a02614cef81338b62464b14444cd888fe">More...</a><br /></td></tr>
<tr class="separator:a02614cef81338b62464b14444cd888fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa5833be6fcdc27289ae3d339625035"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a7aa5833be6fcdc27289ae3d339625035">list_assign_from_range</a> (this, first, last)</td></tr>
<tr class="memdesc:a7aa5833be6fcdc27289ae3d339625035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign new content to container Assigns new contents to the list container, replacing its current contents, and modifying its size accordingly. (1), the new contents are elements constructed from each of the elements in the range between first and last, in the same order. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#a7aa5833be6fcdc27289ae3d339625035">More...</a><br /></td></tr>
<tr class="separator:a7aa5833be6fcdc27289ae3d339625035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c527e5359befaa2b744275b040a2812"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a4c527e5359befaa2b744275b040a2812">list_assign_from_fill</a> (this, n, val)</td></tr>
<tr class="memdesc:a4c527e5359befaa2b744275b040a2812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign new content to container Assigns new contents to the list container, replacing its current contents, and modifying its size accordingly. (2), the new contents are n elements, each initialized to a copy of val.  <a href="namespacem__xfunit__unit__list__ftl.html#a4c527e5359befaa2b744275b040a2812">More...</a><br /></td></tr>
<tr class="separator:a4c527e5359befaa2b744275b040a2812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83edc27c3875fbaedcbabc7be92bd0b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#ad83edc27c3875fbaedcbabc7be92bd0b">list_assign_from_array</a> (this, val)</td></tr>
<tr class="memdesc:ad83edc27c3875fbaedcbabc7be92bd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a list from an array.  <a href="namespacem__xfunit__unit__list__ftl.html#ad83edc27c3875fbaedcbabc7be92bd0b">More...</a><br /></td></tr>
<tr class="separator:ad83edc27c3875fbaedcbabc7be92bd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf59a253ec3458985112e44ff59950ef"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#aaf59a253ec3458985112e44ff59950ef">list_push_front</a> (this, val)</td></tr>
<tr class="memdesc:aaf59a253ec3458985112e44ff59950ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert element at beginning Inserts a new element at the beginning of the list, right before its current first element. The content of val is copied (or moved) to the inserted element. This effectively increases the container size by one.  <a href="namespacem__xfunit__unit__list__ftl.html#aaf59a253ec3458985112e44ff59950ef">More...</a><br /></td></tr>
<tr class="separator:aaf59a253ec3458985112e44ff59950ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723323f81197a9f04f31bc3634f9a6f5"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a723323f81197a9f04f31bc3634f9a6f5">list_pop_front</a> (this)</td></tr>
<tr class="memdesc:a723323f81197a9f04f31bc3634f9a6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete first element Removes the first element in the list container, effectively reducing its size by one. This destroys the removed element.  <a href="namespacem__xfunit__unit__list__ftl.html#a723323f81197a9f04f31bc3634f9a6f5">More...</a><br /></td></tr>
<tr class="separator:a723323f81197a9f04f31bc3634f9a6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5e48a2722bc51666f9037df6dbd801"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#aae5e48a2722bc51666f9037df6dbd801">list_push_back</a> (this, val)</td></tr>
<tr class="memdesc:aae5e48a2722bc51666f9037df6dbd801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add element at the end Adds a new element at the end of the list container, after its current last element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one.  <a href="namespacem__xfunit__unit__list__ftl.html#aae5e48a2722bc51666f9037df6dbd801">More...</a><br /></td></tr>
<tr class="separator:aae5e48a2722bc51666f9037df6dbd801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1901ea9beb0416f258a10378b3179d40"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a1901ea9beb0416f258a10378b3179d40">list_pop_back</a> (this)</td></tr>
<tr class="memdesc:a1901ea9beb0416f258a10378b3179d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete last element Removes the last element in the list container, effectively reducing the container size by one. This destroys the removed element.  <a href="namespacem__xfunit__unit__list__ftl.html#a1901ea9beb0416f258a10378b3179d40">More...</a><br /></td></tr>
<tr class="separator:a1901ea9beb0416f258a10378b3179d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d65223d09398cc537ce72c788ae84be"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a2d65223d09398cc537ce72c788ae84be">list_insert_single</a> (this, iterator, val)</td></tr>
<tr class="memdesc:a2d65223d09398cc537ce72c788ae84be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by one. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#a2d65223d09398cc537ce72c788ae84be">More...</a><br /></td></tr>
<tr class="separator:a2d65223d09398cc537ce72c788ae84be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7493706cdb69464cc3956eefe08982"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a3d7493706cdb69464cc3956eefe08982">list_insert_fill</a> (this, iterator, n, val)</td></tr>
<tr class="memdesc:a3d7493706cdb69464cc3956eefe08982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by n. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#a3d7493706cdb69464cc3956eefe08982">More...</a><br /></td></tr>
<tr class="separator:a3d7493706cdb69464cc3956eefe08982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37711536dea23c65a7c001c9a5156d5a"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a37711536dea23c65a7c001c9a5156d5a">list_insert_range</a> (this, iterator, first, last)</td></tr>
<tr class="memdesc:a37711536dea23c65a7c001c9a5156d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by the number of element in (first,last]. Iterator remains associated to the node in input This assumes that the range (first,last) is an actual connected range, i.e. it is possible to navigate from first to last, otherwise the resulting list is corrupted. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#a37711536dea23c65a7c001c9a5156d5a">More...</a><br /></td></tr>
<tr class="separator:a37711536dea23c65a7c001c9a5156d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af417929575b070e87cf30e800cdfc6e1"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#af417929575b070e87cf30e800cdfc6e1">list_insert_array</a> (this, iterator, val)</td></tr>
<tr class="memdesc:af417929575b070e87cf30e800cdfc6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by the size of the array. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#af417929575b070e87cf30e800cdfc6e1">More...</a><br /></td></tr>
<tr class="separator:af417929575b070e87cf30e800cdfc6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f82a99ff246241e574286c2fe234c84"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a5f82a99ff246241e574286c2fe234c84">list_erase_single</a> (this, iterator)</td></tr>
<tr class="memdesc:a5f82a99ff246241e574286c2fe234c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Removes from the list container either a single element (position) This effectively reduces the container size by one element, which is destroyed. Input iterator returns not associated This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#a5f82a99ff246241e574286c2fe234c84">More...</a><br /></td></tr>
<tr class="separator:a5f82a99ff246241e574286c2fe234c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c187af5e0a3ef150e23833f0b4a545"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#ab7c187af5e0a3ef150e23833f0b4a545">list_erase_range</a> (this, first, last)</td></tr>
<tr class="memdesc:ab7c187af5e0a3ef150e23833f0b4a545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Removes from the list container either a range of elements (first,last). This effectively reduces the container size by the number of elements removed, which are destroyed. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#ab7c187af5e0a3ef150e23833f0b4a545">More...</a><br /></td></tr>
<tr class="separator:ab7c187af5e0a3ef150e23833f0b4a545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48c74cde1891a544e372424d069959f"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#aa48c74cde1891a544e372424d069959f">list_swap</a> (this, other)</td></tr>
<tr class="memdesc:aa48c74cde1891a544e372424d069959f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap content Exchanges the content of the container by the content of other, which is another list of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in other before the call, and the elements of other are those which were in this. All iterators, references and pointers remain valid for the swapped objects.  <a href="namespacem__xfunit__unit__list__ftl.html#aa48c74cde1891a544e372424d069959f">More...</a><br /></td></tr>
<tr class="separator:aa48c74cde1891a544e372424d069959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdd7d5af265e837d7431fae8bda9bf8"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a0cdd7d5af265e837d7431fae8bda9bf8">list_resize</a> (this, n, val)</td></tr>
<tr class="memdesc:a0cdd7d5af265e837d7431fae8bda9bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change size Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized.  <a href="namespacem__xfunit__unit__list__ftl.html#a0cdd7d5af265e837d7431fae8bda9bf8">More...</a><br /></td></tr>
<tr class="separator:a0cdd7d5af265e837d7431fae8bda9bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167cebe67491a72b2e32f0aa261d583d"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a167cebe67491a72b2e32f0aa261d583d">list_clear</a> (this)</td></tr>
<tr class="memdesc:a167cebe67491a72b2e32f0aa261d583d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear content Removes all elements from the list container (which are destroyed) and leaving the container with a size of 0.  <a href="namespacem__xfunit__unit__list__ftl.html#a167cebe67491a72b2e32f0aa261d583d">More...</a><br /></td></tr>
<tr class="separator:a167cebe67491a72b2e32f0aa261d583d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913f8bd1c7a6a71078109239da71af57"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a913f8bd1c7a6a71078109239da71af57">list_at_get</a> (this, idx)</td></tr>
<tr class="memdesc:a913f8bd1c7a6a71078109239da71af57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get reference to element at given position.  <a href="namespacem__xfunit__unit__list__ftl.html#a913f8bd1c7a6a71078109239da71af57">More...</a><br /></td></tr>
<tr class="separator:a913f8bd1c7a6a71078109239da71af57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0788523f58d4166fed5b82df86a3aa2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#ad0788523f58d4166fed5b82df86a3aa2">list_splice_list</a> (this, position, source)</td></tr>
<tr class="memdesc:ad0788523f58d4166fed5b82df86a3aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from list to list Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (1) transfers all the elements of source into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#ad0788523f58d4166fed5b82df86a3aa2">More...</a><br /></td></tr>
<tr class="separator:ad0788523f58d4166fed5b82df86a3aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba50ef6f530df9efa6662c113d6c1f7b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#aba50ef6f530df9efa6662c113d6c1f7b">list_splice_single</a> (this, position, source, it)</td></tr>
<tr class="memdesc:aba50ef6f530df9efa6662c113d6c1f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from list to list Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (2) transfers only the element pointed by iterator from x into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#aba50ef6f530df9efa6662c113d6c1f7b">More...</a><br /></td></tr>
<tr class="separator:aba50ef6f530df9efa6662c113d6c1f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5d0de04f9fa294a3e855eb17a6f220"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a4a5d0de04f9fa294a3e855eb17a6f220">list_splice_range</a> (this, position, source, first, last)</td></tr>
<tr class="memdesc:a4a5d0de04f9fa294a3e855eb17a6f220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from list to list Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (3) transfers the range (first,last) from source into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#a4a5d0de04f9fa294a3e855eb17a6f220">More...</a><br /></td></tr>
<tr class="separator:a4a5d0de04f9fa294a3e855eb17a6f220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b47db4978952809ab1ad7c1ad3c2ef"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#af1b47db4978952809ab1ad7c1ad3c2ef">list_splice_nodes</a> (this, position, source, first, last)</td></tr>
<tr class="memdesc:af1b47db4978952809ab1ad7c1ad3c2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer elements from list to list Actual implementation of splcie at node level This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#af1b47db4978952809ab1ad7c1ad3c2ef">More...</a><br /></td></tr>
<tr class="separator:af1b47db4978952809ab1ad7c1ad3c2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6562c764d047daafc7ef0dcc4ca42d8b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a6562c764d047daafc7ef0dcc4ca42d8b">list_remove</a> (this, val)</td></tr>
<tr class="memdesc:a6562c764d047daafc7ef0dcc4ca42d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements with specific value Removes from the container all the elements that compare equal to val. This calls the destructor of these objects and reduces the container size by the number of elements removed.  <a href="namespacem__xfunit__unit__list__ftl.html#a6562c764d047daafc7ef0dcc4ca42d8b">More...</a><br /></td></tr>
<tr class="separator:a6562c764d047daafc7ef0dcc4ca42d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb0a58c85b6521f88b732afbc4bf0b2"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#aabb0a58c85b6521f88b732afbc4bf0b2">list_remove_if</a> (this, pred)</td></tr>
<tr class="memdesc:aabb0a58c85b6521f88b732afbc4bf0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove elements fulfilling condition Removes from the container all the elements for which Predicate pred returns true. This calls the destructor of these objects and reduces the container size by the number of elements removed. The function calls pred(inodeelement) for each element (where i is an iterator to that element). Any of the elements in the list for which this returns true, are removed from the container.  <a href="namespacem__xfunit__unit__list__ftl.html#aabb0a58c85b6521f88b732afbc4bf0b2">More...</a><br /></td></tr>
<tr class="separator:aabb0a58c85b6521f88b732afbc4bf0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaede2dfc4ef28fd48567588d55ad5a5"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#adaede2dfc4ef28fd48567588d55ad5a5">list_unique</a> (this, bpred)</td></tr>
<tr class="memdesc:adaede2dfc4ef28fd48567588d55ad5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicate values (1) removes all but the first element from every consecutive group of equal elements in the container. (2) takes as argument a specific comparison function that determine the "uniqueness" of an element. In fact, any behavior can be implemented (and not only an equality comparison), but notice that the function will call binary_pred(*i,*j)) for all pairs of elements (where i and j are iterators to the elements) and remove j from the list if the predicate returns true.  <a href="namespacem__xfunit__unit__list__ftl.html#adaede2dfc4ef28fd48567588d55ad5a5">More...</a><br /></td></tr>
<tr class="separator:adaede2dfc4ef28fd48567588d55ad5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e75c59280e0d378d2003992f131e47b"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a1e75c59280e0d378d2003992f131e47b">list_merge</a> (this, other, comp)</td></tr>
<tr class="memdesc:a1e75c59280e0d378d2003992f131e47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge sorted lists Merges other into the list by transferring all of its elements at their respective ordered positions into the container (both containers shall already be ordered). This effectively removes all the elements in other (which becomes empty), and inserts them into their ordered position within container (which expands in size by the number of elements transferred). The operation is performed without constructing nor destroying any element: they are transferred, no matter whether other is an lvalue or an rvalue, or whether the value_type supports move-construction or not. (1) Each element of other is inserted at the position that corresponds to its value according to the strict weak ordering defined by operator &lt; or comp. The resulting order of equivalent elements is stable (i.e., equivalent elements preserve the relative order they had before the call, and existing elements precede those equivalent inserted from other). (2) Take a specific predicate (comp) to perform the comparison operation between elements. This comparison shall produce a strict weak ordering of the elements (i.e., a consistent transitive comparison, without considering its reflexiveness). This function requires that the list containers have their elements already ordered by value (or by comp) before the call. The function does nothing if (other == this).  <a href="namespacem__xfunit__unit__list__ftl.html#a1e75c59280e0d378d2003992f131e47b">More...</a><br /></td></tr>
<tr class="separator:a1e75c59280e0d378d2003992f131e47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2645e118c8267b0442b0427aea52fe32"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a2645e118c8267b0442b0427aea52fe32">list_sort</a> (this, compare)</td></tr>
<tr class="memdesc:a2645e118c8267b0442b0427aea52fe32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort elements in container Sorts the elements in the list, altering their position within the container. (1) The sorting is performed by applying an algorithm that uses operator &lt; to compare elements (2) The sorting is performed by applying an algorithm that uses comp to compare elements. This comparison shall produce a strict weak ordering of the elements (i.e., a consistent transitive comparison, without considering its reflexiveness). The resulting order of equivalent elements is stable: i.e., equivalent elements preserve the relative order they had before the call. The entire operation does not involve the construction, destruction or copy of any element object. Elements are moved within the container.  <a href="namespacem__xfunit__unit__list__ftl.html#a2645e118c8267b0442b0427aea52fe32">More...</a><br /></td></tr>
<tr class="separator:a2645e118c8267b0442b0427aea52fe32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb233acafa5ef2358edf5670c9ce4fc"><td class="memItemLeft" align="right" valign="top">recursive subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#aadb233acafa5ef2358edf5670c9ce4fc">quick_sort</a> (this, left, right, size, compare)</td></tr>
<tr class="memdesc:aadb233acafa5ef2358edf5670c9ce4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorting subroutine (Quick-sort method) algorithm kernel.  <a href="namespacem__xfunit__unit__list__ftl.html#aadb233acafa5ef2358edf5670c9ce4fc">More...</a><br /></td></tr>
<tr class="separator:aadb233acafa5ef2358edf5670c9ce4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9346918e15184a4d6b029bd7e149805b"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a9346918e15184a4d6b029bd7e149805b">swap_nodes</a> (node1, node2)</td></tr>
<tr class="memdesc:a9346918e15184a4d6b029bd7e149805b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two nodes in a list.  <a href="namespacem__xfunit__unit__list__ftl.html#a9346918e15184a4d6b029bd7e149805b">More...</a><br /></td></tr>
<tr class="separator:a9346918e15184a4d6b029bd7e149805b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a1668e74418762d743ff3ef6df9508"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a68a1668e74418762d743ff3ef6df9508">list_iterator_swap_iterators</a> (iter1, iter2)</td></tr>
<tr class="memdesc:a68a1668e74418762d743ff3ef6df9508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two nodes in a list pointed by iterators This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#a68a1668e74418762d743ff3ef6df9508">More...</a><br /></td></tr>
<tr class="separator:a68a1668e74418762d743ff3ef6df9508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7cd32af6d1198125aedf8fcf8a82ed"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a2e7cd32af6d1198125aedf8fcf8a82ed">list_reverse</a> (this)</td></tr>
<tr class="memdesc:a2e7cd32af6d1198125aedf8fcf8a82ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of elements in a list.  <a href="namespacem__xfunit__unit__list__ftl.html#a2e7cd32af6d1198125aedf8fcf8a82ed">More...</a><br /></td></tr>
<tr class="separator:a2e7cd32af6d1198125aedf8fcf8a82ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36998f3572e3e16e29e233751a3ceae"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#af36998f3572e3e16e29e233751a3ceae">list_binary_search</a> (this, item, isless, isgreater)</td></tr>
<tr class="memdesc:af36998f3572e3e16e29e233751a3ceae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search subroutine (assumes ascending sorted list) front-end.  <a href="namespacem__xfunit__unit__list__ftl.html#af36998f3572e3e16e29e233751a3ceae">More...</a><br /></td></tr>
<tr class="separator:af36998f3572e3e16e29e233751a3ceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7181686342ef6648c4a46d7c7ac143"><td class="memItemLeft" align="right" valign="top">recursive type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#add7181686342ef6648c4a46d7c7ac143">recursive_binary_search</a> (left, right, size, item, isless, isgreater)</td></tr>
<tr class="memdesc:add7181686342ef6648c4a46d7c7ac143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search subroutine (assumes ascending sorted list) algorithm kernel.  <a href="namespacem__xfunit__unit__list__ftl.html#add7181686342ef6648c4a46d7c7ac143">More...</a><br /></td></tr>
<tr class="separator:add7181686342ef6648c4a46d7c7ac143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0901c5fc85fedf637df8e16b9c0d8c"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#aae0901c5fc85fedf637df8e16b9c0d8c">list_select</a> (this, reference, bpred)</td></tr>
<tr class="memdesc:aae0901c5fc85fedf637df8e16b9c0d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search a list following certain criteria.  <a href="namespacem__xfunit__unit__list__ftl.html#aae0901c5fc85fedf637df8e16b9c0d8c">More...</a><br /></td></tr>
<tr class="separator:aae0901c5fc85fedf637df8e16b9c0d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6671276c7bf5652b1890c1ec83db2a74"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, dimension(:), allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a6671276c7bf5652b1890c1ec83db2a74">list_array</a> (this)</td></tr>
<tr class="memdesc:a6671276c7bf5652b1890c1ec83db2a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array (allocatabe) of elements from a list.  <a href="namespacem__xfunit__unit__list__ftl.html#a6671276c7bf5652b1890c1ec83db2a74">More...</a><br /></td></tr>
<tr class="separator:a6671276c7bf5652b1890c1ec83db2a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365e901d79a4fcdac40be9d6114d3f34"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a365e901d79a4fcdac40be9d6114d3f34">element_assign_pointer</a> (left, right)</td></tr>
<tr class="memdesc:a365e901d79a4fcdac40be9d6114d3f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it.  <a href="namespacem__xfunit__unit__list__ftl.html#a365e901d79a4fcdac40be9d6114d3f34">More...</a><br /></td></tr>
<tr class="separator:a365e901d79a4fcdac40be9d6114d3f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cea6f143dbe978f9082c628c9039f14"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a7cea6f143dbe978f9082c628c9039f14">element_assign_allocatable</a> (left, right)</td></tr>
<tr class="memdesc:a7cea6f143dbe978f9082c628c9039f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it.  <a href="namespacem__xfunit__unit__list__ftl.html#a7cea6f143dbe978f9082c628c9039f14">More...</a><br /></td></tr>
<tr class="separator:a7cea6f143dbe978f9082c628c9039f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64f79f34991e19e343f3cb16e3e224b"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#af64f79f34991e19e343f3cb16e3e224b">list_iterator_next</a> (this)</td></tr>
<tr class="memdesc:af64f79f34991e19e343f3cb16e3e224b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to next node in the list.  <a href="namespacem__xfunit__unit__list__ftl.html#af64f79f34991e19e343f3cb16e3e224b">More...</a><br /></td></tr>
<tr class="separator:af64f79f34991e19e343f3cb16e3e224b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ea166d69f52fbbe09d80081934b541"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a04ea166d69f52fbbe09d80081934b541">list_iterator_previous</a> (this)</td></tr>
<tr class="memdesc:a04ea166d69f52fbbe09d80081934b541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return iterator to previous node in the list.  <a href="namespacem__xfunit__unit__list__ftl.html#a04ea166d69f52fbbe09d80081934b541">More...</a><br /></td></tr>
<tr class="separator:a04ea166d69f52fbbe09d80081934b541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695bc0d5b6da9c2b5bab99d955962d99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a> function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a695bc0d5b6da9c2b5bab99d955962d99">list_iterator_distance</a> (this, target)</td></tr>
<tr class="memdesc:a695bc0d5b6da9c2b5bab99d955962d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the distance (number of elements) between two iterators The target node must be reacheabke from this using the next operator This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#a695bc0d5b6da9c2b5bab99d955962d99">More...</a><br /></td></tr>
<tr class="separator:a695bc0d5b6da9c2b5bab99d955962d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044862d19bba0002b1582a6cd8839a3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a> function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a044862d19bba0002b1582a6cd8839a3e">list_nodes_distance</a> (origin, target)</td></tr>
<tr class="memdesc:a044862d19bba0002b1582a6cd8839a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the distance (number of elements) between two nodes The target node must be reacheabke from this using the next pointer.  <a href="namespacem__xfunit__unit__list__ftl.html#a044862d19bba0002b1582a6cd8839a3e">More...</a><br /></td></tr>
<tr class="separator:a044862d19bba0002b1582a6cd8839a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fcc1a45f5169766a8ba9a51347c7d3"><td class="memItemLeft" align="right" valign="top">pure <a class="el" href="interfacem__util__convert_1_1logical.html">logical</a> function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a15fcc1a45f5169766a8ba9a51347c7d3">list_iterator_associated</a> (this)</td></tr>
<tr class="memdesc:a15fcc1a45f5169766a8ba9a51347c7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the association status of an iterator.  <a href="namespacem__xfunit__unit__list__ftl.html#a15fcc1a45f5169766a8ba9a51347c7d3">More...</a><br /></td></tr>
<tr class="separator:a15fcc1a45f5169766a8ba9a51347c7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c366e51bb4c191f75f422cb066ac0d"><td class="memItemLeft" align="right" valign="top">pure subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#af7c366e51bb4c191f75f422cb066ac0d">list_iterator_nullify</a> (this)</td></tr>
<tr class="memdesc:af7c366e51bb4c191f75f422cb066ac0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nullify an iterator.  <a href="namespacem__xfunit__unit__list__ftl.html#af7c366e51bb4c191f75f422cb066ac0d">More...</a><br /></td></tr>
<tr class="separator:af7c366e51bb4c191f75f422cb066ac0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19d9bd63c3a1898b367e29c1fb85ecb"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, allocatable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#ab19d9bd63c3a1898b367e29c1fb85ecb">list_iterator_get_element</a> (this)</td></tr>
<tr class="memdesc:ab19d9bd63c3a1898b367e29c1fb85ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an elememnt in the node pointed by the iterator.  <a href="namespacem__xfunit__unit__list__ftl.html#ab19d9bd63c3a1898b367e29c1fb85ecb">More...</a><br /></td></tr>
<tr class="separator:ab19d9bd63c3a1898b367e29c1fb85ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96811d6b82b81f738d21b3b1302e32a"><td class="memItemLeft" align="right" valign="top">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#ad96811d6b82b81f738d21b3b1302e32a">list_iterator_get_element_ptr</a> (this)</td></tr>
<tr class="memdesc:ad96811d6b82b81f738d21b3b1302e32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data elememnt in the node pointed by the iterator.  <a href="namespacem__xfunit__unit__list__ftl.html#ad96811d6b82b81f738d21b3b1302e32a">More...</a><br /></td></tr>
<tr class="separator:ad96811d6b82b81f738d21b3b1302e32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a9b6af020e697786c1c803b536086e"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#aa1a9b6af020e697786c1c803b536086e">list_iterator_set_element</a> (this, val)</td></tr>
<tr class="memdesc:aa1a9b6af020e697786c1c803b536086e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the element in the node pointed by the iterator.  <a href="namespacem__xfunit__unit__list__ftl.html#aa1a9b6af020e697786c1c803b536086e">More...</a><br /></td></tr>
<tr class="separator:aa1a9b6af020e697786c1c803b536086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43f5f11835956be69a4e09406e7228a"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#ad43f5f11835956be69a4e09406e7228a">list_iterator_assign</a> (left, right)</td></tr>
<tr class="memdesc:ad43f5f11835956be69a4e09406e7228a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an interator from an existing iterator (assignment operator) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#ad43f5f11835956be69a4e09406e7228a">More...</a><br /></td></tr>
<tr class="separator:ad43f5f11835956be69a4e09406e7228a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bce3557aadae509eebc12d250780b0"><td class="memItemLeft" align="right" valign="top">pure <a class="el" href="interfacem__util__convert_1_1logical.html">logical</a> function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a17bce3557aadae509eebc12d250780b0">list_iterator_equal</a> (left, right)</td></tr>
<tr class="memdesc:a17bce3557aadae509eebc12d250780b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two iterators (equality) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#a17bce3557aadae509eebc12d250780b0">More...</a><br /></td></tr>
<tr class="separator:a17bce3557aadae509eebc12d250780b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5352f07dd3e8bfd13d618a1c3b8d58e0"><td class="memItemLeft" align="right" valign="top">pure <a class="el" href="interfacem__util__convert_1_1logical.html">logical</a> function&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacem__xfunit__unit__list__ftl.html#a5352f07dd3e8bfd13d618a1c3b8d58e0">list_iterator_not_equal</a> (left, right)</td></tr>
<tr class="memdesc:a5352f07dd3e8bfd13d618a1c3b8d58e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two iterator (inequality) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type.  <a href="namespacem__xfunit__unit__list__ftl.html#a5352f07dd3e8bfd13d618a1c3b8d58e0">More...</a><br /></td></tr>
<tr class="separator:a5352f07dd3e8bfd13d618a1c3b8d58e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="a604849261576666eb8721e373dbd29d4" name="a604849261576666eb8721e373dbd29d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604849261576666eb8721e373dbd29d4">&#9670;&nbsp;</a></span>list_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function m_xfunit_unit_list_ftl::list_default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(1) empty container constructor (default constructor) Constructs an empty container, with no elements. </p>

</div>
</div>
<a id="a6e8b77361a1e14072e8eddf42b193c5e" name="a6e8b77361a1e14072e8eddf42b193c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8b77361a1e14072e8eddf42b193c5e">&#9670;&nbsp;</a></span>list_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function m_xfunit_unit_list_ftl::list_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a>, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(2) fill constructor Constructs a container with n elements. Each element is a copy of val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element to use to fill the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result list </dd></dl>

</div>
</div>
<a id="abf06038330239320cdb0802f6e328811" name="abf06038330239320cdb0802f6e328811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf06038330239320cdb0802f6e328811">&#9670;&nbsp;</a></span>list_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function m_xfunit_unit_list_ftl::list_range </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(3) range constructor Constructs a container with as many elements as the range (first,last), with each element constructed from its corresponding element in that range, in the same order. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to first node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to last node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result list </dd></dl>

</div>
</div>
<a id="ab0322bf8cd3a6e20cfa1f4f8b8a52be2" name="ab0322bf8cd3a6e20cfa1f4f8b8a52be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0322bf8cd3a6e20cfa1f4f8b8a52be2">&#9670;&nbsp;</a></span>list_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function m_xfunit_unit_list_ftl::list_copy </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(4) copy constructor Constructs a container with a copy of each of the elements in other, in the same order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The input list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result list </dd></dl>

</div>
</div>
<a id="a006c513fce1f34d68ed5fbf10f220329" name="a006c513fce1f34d68ed5fbf10f220329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006c513fce1f34d68ed5fbf10f220329">&#9670;&nbsp;</a></span>list_copy_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function m_xfunit_unit_list_ftl::list_copy_from_array </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor from array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The input array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result list </dd></dl>

</div>
</div>
<a id="af1a0bcd70089f0fb22e04eeeba989a01" name="af1a0bcd70089f0fb22e04eeeba989a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a0bcd70089f0fb22e04eeeba989a01">&#9670;&nbsp;</a></span>list_assign_from_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_assign_from_list </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign content Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>The output list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The input list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ff79a9de2cc481c6ecaa31b9f88a548" name="a7ff79a9de2cc481c6ecaa31b9f88a548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff79a9de2cc481c6ecaa31b9f88a548">&#9670;&nbsp;</a></span>list_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine m_xfunit_unit_list_ftl::list_ </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List destructor Destroys the container object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0de5e17830aa3f0d9aa2d25497e3300d" name="a0de5e17830aa3f0d9aa2d25497e3300d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de5e17830aa3f0d9aa2d25497e3300d">&#9670;&nbsp;</a></span>list_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function m_xfunit_unit_list_ftl::list_begin </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to beginning Returns an iterator pointing to the first element in the list container. If the container is empty, the returned iterator value shall not be dereferenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to beginning of the list </dd></dl>

</div>
</div>
<a id="acae697f5792f9cfd64326858fc0f3027" name="acae697f5792f9cfd64326858fc0f3027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae697f5792f9cfd64326858fc0f3027">&#9670;&nbsp;</a></span>list_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function m_xfunit_unit_list_ftl::list_end </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to end Returns an iterator referring to the last element in the list container. If the container is empty, the returned iterator value shall not be dereferenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to end of the list </dd></dl>

</div>
</div>
<a id="a417e01314b60f763d04b3ea4cd5e2bdf" name="a417e01314b60f763d04b3ea4cd5e2bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417e01314b60f763d04b3ea4cd5e2bdf">&#9670;&nbsp;</a></span>list_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure <a class="el" href="interfacem__util__convert_1_1logical.html">logical</a> function m_xfunit_unit_list_ftl::list_empty </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether container is empty Returns whether the list container is empty (i.e. whether its size is 0). This function does not modify the container in any way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list empty status </dd></dl>

</div>
</div>
<a id="aecf4b3ee8abea3c4cbedaea415fb09ec" name="aecf4b3ee8abea3c4cbedaea415fb09ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf4b3ee8abea3c4cbedaea415fb09ec">&#9670;&nbsp;</a></span>list_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure <a class="el" href="interfacem__util__convert_1_1integer.html">integer</a> function m_xfunit_unit_list_ftl::list_size </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return size Returns the number of elements in the list container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list size </dd></dl>

</div>
</div>
<a id="a4d3aad07af32e9c866f6133532b6d117" name="a4d3aad07af32e9c866f6133532b6d117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3aad07af32e9c866f6133532b6d117">&#9670;&nbsp;</a></span>list_max_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure <a class="el" href="interfacem__util__convert_1_1integer.html">integer</a> function m_xfunit_unit_list_ftl::list_max_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return maximum size Returns the maximum number of elements that the list container can hold. This is the maximum potential size the container can reach due to known system or library implementation limitations, but the container is by no means guaranteed to be able to reach that size: it can still fail to allocate storage at any point before that size is reached. </p>

</div>
</div>
<a id="a6b0bb9e23aa8c5f2895e0095158303b3" name="a6b0bb9e23aa8c5f2895e0095158303b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0bb9e23aa8c5f2895e0095158303b3">&#9670;&nbsp;</a></span>list_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, allocatable m_xfunit_unit_list_ftl::list_front </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access first element Returns a reference to the first element in the list container. Calling this function on an empty container causes undefined behaviour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the element in the first node in the list </dd></dl>

</div>
</div>
<a id="a02614cef81338b62464b14444cd888fe" name="a02614cef81338b62464b14444cd888fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02614cef81338b62464b14444cd888fe">&#9670;&nbsp;</a></span>list_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, allocatable m_xfunit_unit_list_ftl::list_back </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access last element Returns a reference to the last element in the list container. Calling this function on an empty container causes undefined behaviour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the element in the last node in the list </dd></dl>

</div>
</div>
<a id="a7aa5833be6fcdc27289ae3d339625035" name="a7aa5833be6fcdc27289ae3d339625035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa5833be6fcdc27289ae3d339625035">&#9670;&nbsp;</a></span>list_assign_from_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_assign_from_range </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign new content to container Assigns new contents to the list container, replacing its current contents, and modifying its size accordingly. (1), the new contents are elements constructed from each of the elements in the range between first and last, in the same order. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>The output list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to first node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to last node to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c527e5359befaa2b744275b040a2812" name="a4c527e5359befaa2b744275b040a2812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c527e5359befaa2b744275b040a2812">&#9670;&nbsp;</a></span>list_assign_from_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_assign_from_fill </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a>, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign new content to container Assigns new contents to the list container, replacing its current contents, and modifying its size accordingly. (2), the new contents are n elements, each initialized to a copy of val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>The output list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element to used to populate the container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad83edc27c3875fbaedcbabc7be92bd0b" name="ad83edc27c3875fbaedcbabc7be92bd0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83edc27c3875fbaedcbabc7be92bd0b">&#9670;&nbsp;</a></span>list_assign_from_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_assign_from_array </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(out)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a list from an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">this</td><td>The output list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The input array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf59a253ec3458985112e44ff59950ef" name="aaf59a253ec3458985112e44ff59950ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf59a253ec3458985112e44ff59950ef">&#9670;&nbsp;</a></span>list_push_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_push_front </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert element at beginning Inserts a new element at the beginning of the list, right before its current first element. The content of val is copied (or moved) to the inserted element. This effectively increases the container size by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a723323f81197a9f04f31bc3634f9a6f5" name="a723323f81197a9f04f31bc3634f9a6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723323f81197a9f04f31bc3634f9a6f5">&#9670;&nbsp;</a></span>list_pop_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine m_xfunit_unit_list_ftl::list_pop_front </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete first element Removes the first element in the list container, effectively reducing its size by one. This destroys the removed element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae5e48a2722bc51666f9037df6dbd801" name="aae5e48a2722bc51666f9037df6dbd801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5e48a2722bc51666f9037df6dbd801">&#9670;&nbsp;</a></span>list_push_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_push_back </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add element at the end Adds a new element at the end of the list container, after its current last element. The content of val is copied (or moved) to the new element. This effectively increases the container size by one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1901ea9beb0416f258a10378b3179d40" name="a1901ea9beb0416f258a10378b3179d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1901ea9beb0416f258a10378b3179d40">&#9670;&nbsp;</a></span>list_pop_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine m_xfunit_unit_list_ftl::list_pop_back </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete last element Removes the last element in the list container, effectively reducing the container size by one. This destroys the removed element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d65223d09398cc537ce72c788ae84be" name="a2d65223d09398cc537ce72c788ae84be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d65223d09398cc537ce72c788ae84be">&#9670;&nbsp;</a></span>list_insert_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function m_xfunit_unit_list_ftl::list_insert_single </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by one. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>Iterator to node used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted element </dd></dl>

</div>
</div>
<a id="a3d7493706cdb69464cc3956eefe08982" name="a3d7493706cdb69464cc3956eefe08982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7493706cdb69464cc3956eefe08982">&#9670;&nbsp;</a></span>list_insert_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function m_xfunit_unit_list_ftl::list_insert_fill </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a>, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by n. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>Iterator to node used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of times to insert the element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted element </dd></dl>

</div>
</div>
<a id="a37711536dea23c65a7c001c9a5156d5a" name="a37711536dea23c65a7c001c9a5156d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37711536dea23c65a7c001c9a5156d5a">&#9670;&nbsp;</a></span>list_insert_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function m_xfunit_unit_list_ftl::list_insert_range </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by the number of element in (first,last]. Iterator remains associated to the node in input This assumes that the range (first,last) is an actual connected range, i.e. it is possible to navigate from first to last, otherwise the resulting list is corrupted. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>Iterator to node used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to first node to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to last node to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted element </dd></dl>

</div>
</div>
<a id="af417929575b070e87cf30e800cdfc6e1" name="af417929575b070e87cf30e800cdfc6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af417929575b070e87cf30e800cdfc6e1">&#9670;&nbsp;</a></span>list_insert_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function m_xfunit_unit_list_ftl::list_insert_array </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert elements The container is extended by inserting new elements before the element at the specified position. This effectively increases the list size by the size of the array. Iterator remains associated to the node in input This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterator</td><td>Iterator to node used as reference for insertion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the inserted element </dd></dl>

</div>
</div>
<a id="a5f82a99ff246241e574286c2fe234c84" name="a5f82a99ff246241e574286c2fe234c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f82a99ff246241e574286c2fe234c84">&#9670;&nbsp;</a></span>list_erase_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_erase_single </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iterator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements Removes from the list container either a single element (position) This effectively reduces the container size by one element, which is destroyed. Input iterator returns not associated This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterator</td><td>Iterator to node to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7c187af5e0a3ef150e23833f0b4a545" name="ab7c187af5e0a3ef150e23833f0b4a545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c187af5e0a3ef150e23833f0b4a545">&#9670;&nbsp;</a></span>list_erase_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_erase_range </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase elements Removes from the list container either a range of elements (first,last). This effectively reduces the container size by the number of elements removed, which are destroyed. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Iterator to first node to remove </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Iterator to last node to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa48c74cde1891a544e372424d069959f" name="aa48c74cde1891a544e372424d069959f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48c74cde1891a544e372424d069959f">&#9670;&nbsp;</a></span>list_swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine m_xfunit_unit_list_ftl::list_swap </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap content Exchanges the content of the container by the content of other, which is another list of the same type. Sizes may differ. After the call to this member function, the elements in this container are those which were in other before the call, and the elements of other are those which were in this. All iterators, references and pointers remain valid for the swapped objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The list to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cdd7d5af265e837d7431fae8bda9bf8" name="a0cdd7d5af265e837d7431fae8bda9bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdd7d5af265e837d7431fae8bda9bf8">&#9670;&nbsp;</a></span>list_resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_resize </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a>, intent(in)&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in), optional, target&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change size Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The number of elements in the resulting list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element to use to initialise traling elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a167cebe67491a72b2e32f0aa261d583d" name="a167cebe67491a72b2e32f0aa261d583d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167cebe67491a72b2e32f0aa261d583d">&#9670;&nbsp;</a></span>list_clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine m_xfunit_unit_list_ftl::list_clear </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear content Removes all elements from the list container (which are destroyed) and leaving the container with a size of 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a913f8bd1c7a6a71078109239da71af57" name="a913f8bd1c7a6a71078109239da71af57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a913f8bd1c7a6a71078109239da71af57">&#9670;&nbsp;</a></span>list_at_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, pointer m_xfunit_unit_list_ftl::list_at_get </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a>, intent(in)&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get reference to element at given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The position in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object to replace </dd></dl>

</div>
</div>
<a id="ad0788523f58d4166fed5b82df86a3aa2" name="ad0788523f58d4166fed5b82df86a3aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0788523f58d4166fed5b82df86a3aa2">&#9670;&nbsp;</a></span>list_splice_list()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_splice_list </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from list to list Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (1) transfers all the elements of source into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position in list to insert the elements </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba50ef6f530df9efa6662c113d6c1f7b" name="aba50ef6f530df9efa6662c113d6c1f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba50ef6f530df9efa6662c113d6c1f7b">&#9670;&nbsp;</a></span>list_splice_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_splice_single </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from list to list Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (2) transfers only the element pointed by iterator from x into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position in list to insert the elements </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>The element position in source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a5d0de04f9fa294a3e855eb17a6f220" name="a4a5d0de04f9fa294a3e855eb17a6f220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5d0de04f9fa294a3e855eb17a6f220">&#9670;&nbsp;</a></span>list_splice_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_splice_range </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from list to list Transfers elements from source into the container, inserting them at position. This effectively inserts those elements into the container and removes them from source, altering the sizes of both containers. The operation does not involve the construction or destruction of any element. (3) transfers the range (first,last) from source into the container. This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position in list to insert the elements </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first position in source to retrieve elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The last position in source to retrieve elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1b47db4978952809ab1ad7c1ad3c2ef" name="af1b47db4978952809ab1ad7c1ad3c2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b47db4978952809ab1ad7c1ad3c2ef">&#9670;&nbsp;</a></span>list_splice_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_splice_nodes </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__assertion__list__ftl_1_1t__list__node.html">t_list_node</a>), intent(in), pointer&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__assertion__list__ftl_1_1t__list__node.html">t_list_node</a>), intent(in), pointer&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer elements from list to list Actual implementation of splcie at node level This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<p >Splice as in C++ cannot append lists because the end iterator returns the poisiton of the last-element and not the past-last-element. To circumvent this problem, provision of position=null identfied insert after the end of the list )after last element) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The position in list to insert the elements </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">source</td><td>The source list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>The first position in source to retrieve elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>The last position in source to retrieve elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6562c764d047daafc7ef0dcc4ca42d8b" name="a6562c764d047daafc7ef0dcc4ca42d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6562c764d047daafc7ef0dcc4ca42d8b">&#9670;&nbsp;</a></span>list_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_remove </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove elements with specific value Removes from the container all the elements that compare equal to val. This calls the destructor of these objects and reduces the container size by the number of elements removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to use as comparison for the removal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabb0a58c85b6521f88b732afbc4bf0b2" name="aabb0a58c85b6521f88b732afbc4bf0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb0a58c85b6521f88b732afbc4bf0b2">&#9670;&nbsp;</a></span>list_remove_if()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_remove_if </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacem__xfunit__assertion__list__ftl_1_1predicate.html">predicate</a>)&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove elements fulfilling condition Removes from the container all the elements for which Predicate pred returns true. This calls the destructor of these objects and reduces the container size by the number of elements removed. The function calls pred(inodeelement) for each element (where i is an iterator to that element). Any of the elements in the list for which this returns true, are removed from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pred</td><td>THe predicate to use for removal selection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaede2dfc4ef28fd48567588d55ad5a5" name="adaede2dfc4ef28fd48567588d55ad5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaede2dfc4ef28fd48567588d55ad5a5">&#9670;&nbsp;</a></span>list_unique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_unique </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacem__xfunit__assertion__list__ftl_1_1binary__predicate.html">binary_predicate</a>), optional&#160;</td>
          <td class="paramname"><em>bpred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove duplicate values (1) removes all but the first element from every consecutive group of equal elements in the container. (2) takes as argument a specific comparison function that determine the "uniqueness" of an element. In fact, any behavior can be implemented (and not only an equality comparison), but notice that the function will call binary_pred(*i,*j)) for all pairs of elements (where i and j are iterators to the elements) and remove j from the list if the predicate returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bpred</td><td>The interface for the binary predicate (optional) If the operator is not provided, then operator(==) is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e75c59280e0d378d2003992f131e47b" name="a1e75c59280e0d378d2003992f131e47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e75c59280e0d378d2003992f131e47b">&#9670;&nbsp;</a></span>list_merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_merge </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout), target&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacem__xfunit__assertion__list__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge sorted lists Merges other into the list by transferring all of its elements at their respective ordered positions into the container (both containers shall already be ordered). This effectively removes all the elements in other (which becomes empty), and inserts them into their ordered position within container (which expands in size by the number of elements transferred). The operation is performed without constructing nor destroying any element: they are transferred, no matter whether other is an lvalue or an rvalue, or whether the value_type supports move-construction or not. (1) Each element of other is inserted at the position that corresponds to its value according to the strict weak ordering defined by operator &lt; or comp. The resulting order of equivalent elements is stable (i.e., equivalent elements preserve the relative order they had before the call, and existing elements precede those equivalent inserted from other). (2) Take a specific predicate (comp) to perform the comparison operation between elements. This comparison shall produce a strict weak ordering of the elements (i.e., a consistent transitive comparison, without considering its reflexiveness). This function requires that the list containers have their elements already ordered by value (or by comp) before the call. The function does nothing if (other == this). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">other</td><td>The list to merge </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp</td><td>Comparison function (optional) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2645e118c8267b0442b0427aea52fe32" name="a2645e118c8267b0442b0427aea52fe32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2645e118c8267b0442b0427aea52fe32">&#9670;&nbsp;</a></span>list_sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_sort </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacem__xfunit__assertion__list__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort elements in container Sorts the elements in the list, altering their position within the container. (1) The sorting is performed by applying an algorithm that uses operator &lt; to compare elements (2) The sorting is performed by applying an algorithm that uses comp to compare elements. This comparison shall produce a strict weak ordering of the elements (i.e., a consistent transitive comparison, without considering its reflexiveness). The resulting order of equivalent elements is stable: i.e., equivalent elements preserve the relative order they had before the call. The entire operation does not involve the construction, destruction or copy of any element object. Elements are moved within the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list to sort </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">compare</td><td>The interface for the comparison operator (optional) If the operator is not provided, then operator(&lt;) is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadb233acafa5ef2358edf5670c9ce4fc" name="aadb233acafa5ef2358edf5670c9ce4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb233acafa5ef2358edf5670c9ce4fc">&#9670;&nbsp;</a></span>quick_sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">recursive subroutine m_xfunit_unit_list_ftl::quick_sort </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__assertion__list__ftl_1_1t__list__node.html">t_list_node</a>), pointer&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__assertion__list__ftl_1_1t__list__node.html">t_list_node</a>), pointer&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a>, intent(in)&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacem__xfunit__assertion__list__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorting subroutine (Quick-sort method) algorithm kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list to sort </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">left</td><td>Quick-sort partition left position </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">right</td><td>Quick-sort partition right position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of node between left and right (including selves) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">compare</td><td>The interface for the comparison operator (optional) If the operator is not provided, then operator(&lt;) is assumed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9346918e15184a4d6b029bd7e149805b" name="a9346918e15184a4d6b029bd7e149805b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9346918e15184a4d6b029bd7e149805b">&#9670;&nbsp;</a></span>swap_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine m_xfunit_unit_list_ftl::swap_nodes </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__assertion__list__ftl_1_1t__list__node.html">t_list_node</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__assertion__list__ftl_1_1t__list__node.html">t_list_node</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two nodes in a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">node1</td><td>Iterator to first element </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">node2</td><td>Iterator to second element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68a1668e74418762d743ff3ef6df9508" name="a68a1668e74418762d743ff3ef6df9508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a1668e74418762d743ff3ef6df9508">&#9670;&nbsp;</a></span>list_iterator_swap_iterators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine m_xfunit_unit_list_ftl::list_iterator_swap_iterators </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>iter2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two nodes in a list pointed by iterators This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter1</td><td>Iterator to first element </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iter2</td><td>Iterator to second element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e7cd32af6d1198125aedf8fcf8a82ed" name="a2e7cd32af6d1198125aedf8fcf8a82ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7cd32af6d1198125aedf8fcf8a82ed">&#9670;&nbsp;</a></span>list_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine m_xfunit_unit_list_ftl::list_reverse </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse the order of elements in a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list to reverse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af36998f3572e3e16e29e233751a3ceae" name="af36998f3572e3e16e29e233751a3ceae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36998f3572e3e16e29e233751a3ceae">&#9670;&nbsp;</a></span>list_binary_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function m_xfunit_unit_list_ftl::list_binary_search </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacem__xfunit__assertion__list__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>isless</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacem__xfunit__assertion__list__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>isgreater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary search subroutine (assumes ascending sorted list) front-end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list to search </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>The element to look for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">isless</td><td>If the operator is not provided, then operator(&lt;) is assumed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">isgreater</td><td>If the operator is not provided, then operator(&gt;) is assumed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator to the list element (not associated if not found) </dd></dl>

</div>
</div>
<a id="add7181686342ef6648c4a46d7c7ac143" name="add7181686342ef6648c4a46d7c7ac143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7181686342ef6648c4a46d7c7ac143">&#9670;&nbsp;</a></span>recursive_binary_search()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">recursive type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function m_xfunit_unit_list_ftl::recursive_binary_search </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__assertion__list__ftl_1_1t__list__node.html">t_list_node</a>), intent(in), target&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__assertion__list__ftl_1_1t__list__node.html">t_list_node</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a>, intent(in)&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacem__xfunit__assertion__list__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>isless</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacem__xfunit__assertion__list__ftl_1_1comparison.html">comparison</a>), optional&#160;</td>
          <td class="paramname"><em>isgreater</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary search subroutine (assumes ascending sorted list) algorithm kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>Quick-sort partition left position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Quick-sort partition right position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of node between left and right (including selves) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">item</td><td>The element to look for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">isless</td><td>If the operator is not provided, then operator(&lt;) is assumed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">isgreater</td><td>If the operator is not provided, then operator(&gt;) is assumed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator to the list element (not associated if not found) </dd></dl>

</div>
</div>
<a id="aae0901c5fc85fedf637df8e16b9c0d8c" name="aae0901c5fc85fedf637df8e16b9c0d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0901c5fc85fedf637df8e16b9c0d8c">&#9670;&nbsp;</a></span>list_select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>) function m_xfunit_unit_list_ftl::list_select </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">procedure(<a class="el" href="interfacem__xfunit__assertion__list__ftl_1_1binary__predicate.html">binary_predicate</a>), optional&#160;</td>
          <td class="paramname"><em>bpred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search a list following certain criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list to search selected items </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>The reference element to use as selecting pattern </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">bpred</td><td>The interface for the comparison operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output list contatining the selected elements </dd></dl>

</div>
</div>
<a id="a6671276c7bf5652b1890c1ec83db2a74" name="a6671276c7bf5652b1890c1ec83db2a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6671276c7bf5652b1890c1ec83db2a74">&#9670;&nbsp;</a></span>list_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, dimension(:), allocatable m_xfunit_unit_list_ftl::list_array </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl.html">t_xfunit_unit_list_ftl</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an array (allocatabe) of elements from a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The input list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned array of elements (unallocated if memory failure) </dd></dl>

</div>
</div>
<a id="a365e901d79a4fcdac40be9d6114d3f34" name="a365e901d79a4fcdac40be9d6114d3f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365e901d79a4fcdac40be9d6114d3f34">&#9670;&nbsp;</a></span>element_assign_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::element_assign_pointer </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(inout), pointer&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">left</td><td>Element to be allocated and assigned (pointer interface) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Source element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cea6f143dbe978f9082c628c9039f14" name="a7cea6f143dbe978f9082c628c9039f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cea6f143dbe978f9082c628c9039f14">&#9670;&nbsp;</a></span>element_assign_allocatable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::element_assign_allocatable </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(inout), allocatable&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implement the assignment between two elements (contained in the container node) Centralises the implementation allowing the handling of polymorphism (store parent classes pointing derived clasess) at the time thta allows the invocation of assignment operators in the cases when the element implements it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">left</td><td>Element to be allocated and assigned (allocatable interface) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>Source element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af64f79f34991e19e343f3cb16e3e224b" name="af64f79f34991e19e343f3cb16e3e224b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64f79f34991e19e343f3cb16e3e224b">&#9670;&nbsp;</a></span>list_iterator_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function m_xfunit_unit_list_ftl::list_iterator_next </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to next node in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to next node in the list </dd></dl>

</div>
</div>
<a id="a04ea166d69f52fbbe09d80081934b541" name="a04ea166d69f52fbbe09d80081934b541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ea166d69f52fbbe09d80081934b541">&#9670;&nbsp;</a></span>list_iterator_previous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>) function m_xfunit_unit_list_ftl::list_iterator_previous </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return iterator to previous node in the list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous node in the list </dd></dl>

</div>
</div>
<a id="a695bc0d5b6da9c2b5bab99d955962d99" name="a695bc0d5b6da9c2b5bab99d955962d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695bc0d5b6da9c2b5bab99d955962d99">&#9670;&nbsp;</a></span>list_iterator_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a> function m_xfunit_unit_list_ftl::list_iterator_distance </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the distance (number of elements) between two iterators The target node must be reacheabke from this using the next operator This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The first list iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The final list iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements between the iterators </dd></dl>

</div>
</div>
<a id="a044862d19bba0002b1582a6cd8839a3e" name="a044862d19bba0002b1582a6cd8839a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044862d19bba0002b1582a6cd8839a3e">&#9670;&nbsp;</a></span>list_nodes_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfacem__util__convert_1_1integer.html">integer</a> function m_xfunit_unit_list_ftl::list_nodes_distance </td>
          <td>(</td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__assertion__list__ftl_1_1t__list__node.html">t_list_node</a>), intent(in), pointer&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__assertion__list__ftl_1_1t__list__node.html">t_list_node</a>), intent(in), pointer&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the distance (number of elements) between two nodes The target node must be reacheabke from this using the next pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>The first node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target</td><td>The final node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements between the iterators </dd></dl>

</div>
</div>
<a id="a15fcc1a45f5169766a8ba9a51347c7d3" name="a15fcc1a45f5169766a8ba9a51347c7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fcc1a45f5169766a8ba9a51347c7d3">&#9670;&nbsp;</a></span>list_iterator_associated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure <a class="el" href="interfacem__util__convert_1_1logical.html">logical</a> function m_xfunit_unit_list_ftl::list_iterator_associated </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the association status of an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The list iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The association status </dd></dl>

</div>
</div>
<a id="af7c366e51bb4c191f75f422cb066ac0d" name="af7c366e51bb4c191f75f422cb066ac0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c366e51bb4c191f75f422cb066ac0d">&#9670;&nbsp;</a></span>list_iterator_nullify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure subroutine m_xfunit_unit_list_ftl::list_iterator_nullify </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nullify an iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The list iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab19d9bd63c3a1898b367e29c1fb85ecb" name="ab19d9bd63c3a1898b367e29c1fb85ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19d9bd63c3a1898b367e29c1fb85ecb">&#9670;&nbsp;</a></span>list_iterator_get_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, allocatable m_xfunit_unit_list_ftl::list_iterator_get_element </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an elememnt in the node pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned pointer to element </dd></dl>

</div>
</div>
<a id="ad96811d6b82b81f738d21b3b1302e32a" name="ad96811d6b82b81f738d21b3b1302e32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96811d6b82b81f738d21b3b1302e32a">&#9670;&nbsp;</a></span>list_iterator_get_element_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>) function, pointer m_xfunit_unit_list_ftl::list_iterator_get_element_ptr </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>this</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data elememnt in the node pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">this</td><td>The iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned pointer to element </dd></dl>

</div>
</div>
<a id="aa1a9b6af020e697786c1c803b536086e" name="aa1a9b6af020e697786c1c803b536086e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a9b6af020e697786c1c803b536086e">&#9670;&nbsp;</a></span>list_iterator_set_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_iterator_set_element </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(inout)&#160;</td>
          <td class="paramname"><em>this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type(<a class="el" href="structm__xfunit__unit_1_1t__xfunit__unit.html">t_xfunit_unit</a>), intent(in)&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the element in the node pointed by the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">this</td><td>The iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The element to be assigned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad43f5f11835956be69a4e09406e7228a" name="ad43f5f11835956be69a4e09406e7228a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43f5f11835956be69a4e09406e7228a">&#9670;&nbsp;</a></span>list_iterator_assign()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">subroutine m_xfunit_unit_list_ftl::list_iterator_assign </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(out)&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an interator from an existing iterator (assignment operator) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">left</td><td>The output iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The input iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17bce3557aadae509eebc12d250780b0" name="a17bce3557aadae509eebc12d250780b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bce3557aadae509eebc12d250780b0">&#9670;&nbsp;</a></span>list_iterator_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure <a class="el" href="interfacem__util__convert_1_1logical.html">logical</a> function m_xfunit_unit_list_ftl::list_iterator_equal </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two iterators (equality) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The first iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The second iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison result </dd></dl>

</div>
</div>
<a id="a5352f07dd3e8bfd13d618a1c3b8d58e0" name="a5352f07dd3e8bfd13d618a1c3b8d58e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5352f07dd3e8bfd13d618a1c3b8d58e0">&#9670;&nbsp;</a></span>list_iterator_not_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pure <a class="el" href="interfacem__util__convert_1_1logical.html">logical</a> function m_xfunit_unit_list_ftl::list_iterator_not_equal </td>
          <td>(</td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(<a class="el" href="structm__xfunit__unit__list__ftl_1_1t__xfunit__unit__list__ftl__iterator.html">t_xfunit_unit_list_ftl_iterator</a>), intent(in)&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two iterator (inequality) This interface is also designed to allow inheritance of the list type and then to extend also the list_iterator type such that the derived list type can invoke this method with the derivied list_iterator type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>The first iterator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>The second iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison result </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
